From ccd8aa1323b75e6f3cefacde7ed6cece6457a70b Mon Sep 17 00:00:00 2001
From: Thomas Orozco <thomas@orozco.fr>
Date: Fri, 8 Apr 2016 22:19:20 +0200
Subject: [PATCH] Periodically refresh PartitionCache

This complements the addition of the PartitionCache with a periodic
refresh, which ensures information doesn't stale for too long.

This is useful considering some methods of PartitionCache
(ApplyOverLabels and ApplyOverPartitions) can't know whether they
returned the data the receiver cared about or not and therefore can't
know to refresh the cache.
---
 manager/manager.go | 24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/manager/manager.go b/manager/manager.go
index aa6d186..04ecc99 100644
--- a/manager/manager.go
+++ b/manager/manager.go
@@ -148,7 +148,7 @@ func New(memoryCache *memory.InMemoryCache, sysfs sysfs.SysFs, maxHousekeepingIn
 
 	newManager := &manager{
 		containers:               make(map[namespacedContainerName]*containerData),
-		quitChannels:             make([]chan error, 0, 2),
+		quitChannels:             make([]chan error, 0, 3),
 		memoryCache:              memoryCache,
 		fsInfo:                   fsInfo,
 		cadvisorContainer:        selfContainer,
@@ -254,6 +254,11 @@ func (self *manager) Start() error {
 	self.quitChannels = append(self.quitChannels, quitGlobalHousekeeping)
 	go self.globalHousekeeping(quitGlobalHousekeeping)
 
+	// Update FS info to prevent it from going stale
+	quitFsInfoCacheManager := make(chan error)
+	self.quitChannels = append(self.quitChannels, quitFsInfoCacheManager)
+	go self.fsInfoCacheRefreshLoop(quitFsInfoCacheManager)
+
 	return nil
 }
 
@@ -269,10 +274,25 @@ func (self *manager) Stop() error {
 			return err
 		}
 	}
-	self.quitChannels = make([]chan error, 0, 2)
+	self.quitChannels = make([]chan error, 0, 3)
 	return nil
 }
 
+func (self *manager) fsInfoCacheRefreshLoop(quit chan error) {
+	ticker := time.Tick(1 * time.Minute)
+
+	for {
+		select {
+		case <-ticker:
+			self.fsInfo.RefreshCache()
+		case <-quit:
+			quit <- nil
+			glog.Infof("Exiting fsInfoCacheRefreshLoop")
+			return
+		}
+	}
+}
+
 func (self *manager) globalHousekeeping(quit chan error) {
 	// Long housekeeping is either 100ms or half of the housekeeping interval.
 	longHousekeeping := 100 * time.Millisecond
-- 
2.7.4

